---
title: "ToDo"
---

Remotes:



    easystats/correlation,
    easystats/report










# Future Works:

## ndphillips/FFTrees











```
            # gtsummary

            # myvars <- jmvcore::constructFormula(terms = self$options$vars)
            # myvars <- jmvcore::decomposeFormula(formula = myvars)
            # myvars <- unlist(myvars)
            # mytableone2 <- self$data %>%
            #     dplyr::select(myvars)
            # mytableone2 <- gtsummary::tbl_summary(mytableone2)
            # self$results$text2$setContent(mytableone2)
```


    # - name: outcomeLevel
    #   title: |
    #       Select Event (Death, Recurrence)
    #   type: Level
    #   variable: (outcome)







---

,
arsenal,

rlang,
knitr,
remotes,
kableExtra,

caret,
irr
Remotes:


easystats/bayestestR,
easystats/performance,
easystats/parameters,
easystats/report
Suggests:
    effectsize,
emmeans,
rmarkdown,
igraph,
iterators,
rms,
commonmark,
sass







```
# #
# #
# #     if (is.null(self$options$dep) || is.null(self$options$group))
# #         return()
# #
# #     mydata <- self$data
# #
# #     mydep <- self$data[[self$options$dep]]
# #
# #     mygroup <- self$data[[self$options$group]]
# #
# #
# #     # klass <- print(
# #     #     list(
# #     #         "mydep" = c(typeof(mydep), class(mydep)),
# #     #         "mygroup" = c(typeof(mygroup), class(mygroup))
# #     #         )
# #     #     )
# #
# #
# #     # self$results$text1$setContent(klass)
# #
# #
# #     # plotData <- data.frame(gr = mygroup,
# #     #                        dp = mydep)
# #     # plotData <- jmvcore::naOmit(plotData)
# #     # mydata_changes <- plotData %>%
# #     #     dplyr::group_by(gr, dp) %>%
# #     #     dplyr::tally(x = .)
# #     #
# #     # self$results$text2$setContent(mydata_changes)
# #     #
# #     # plotData <- data.frame(gr = mygroup,
# #     #                        dp = mydep)
# #     #
# #     # plotData <- jmvcore::naOmit(plotData)
# #     #
# #     #
# #     # mydata_changes <- plotData %>%
# #     #     dplyr::group_by(gr, dp) %>%
# #     #     dplyr::tally(x = .)
# #     #
# #     #
# #     # deneme <- ggalluvial::is_alluvia_form(
# #     #     as.data.frame(mydata_changes),
# #     #     axes = 1:2, silent = TRUE)
# #
# #     # nodes = data.frame("name" =
# #     #                        c(self$options$group,
# #     #                          self$options$dep))
# #     #
# #     # links <- mydata_changes
# #     #
# #     # names(links) = c("source", "target", "value")
# #     #
# #     # deneme <- networkD3::sankeyNetwork(Links = links, Nodes = nodes,
# #     #                                  Source = "source", Target = "target",
# #     #                                  Value = "value", NodeID = "name",
# #     #                                  fontSize= 12, nodeWidth = 30)
# #
# #
# #
# #     # self$results$text3$setContent(deneme)
# #
# #
# #
# #
# #     # Prepare Data for Plot ----
# #
# #     direction <- self$options$direction
# #
# #     mydata <- self$data
# #
# #     mydep <- self$data[[self$options$dep]]
# #
# #     mygroup <- self$data[[self$options$group]]
# #
# #     contin <- c("integer", "numeric", "double")
# #     categ <- c("factor")
# #
# # # independent, factor, continuous ----
# # # ggbetweenstats 	violin plots 	for comparisons between groups/conditions
# #     if (direction == "independent" && class(mygroup) == "factor" && class(mydep) %in% contin) {
# #             plotData <- data.frame(gr = mygroup,
# #                                    dp = jmvcore::toNumeric(mydep))
# #
# #
# #
# #             todo <- glue::glue(
# #                 "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         -
# #         -  "
# #             )
# #
# #
# #
# #         }
# #
# #
# # # independent, continuous, continuous ----
# # # ggscatterstats 	scatterplots 	for correlations between two variables
# #
# #     if (direction == "independent" && class(mygroup) %in% contin && class(mydep) %in% contin) {
# #             plotData <- data.frame(gr = jmvcore::toNumeric(mygroup),
# #                                    dp = jmvcore::toNumeric(mydep))
# #
# #
# #
# #
# #             todo <- glue::glue(
# #                 "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         -
# #         -  "
# #             )
# #     }
# #
# #
# # # independent, factor, factor ----
# # # ggbarstats 	bar charts 	for categorical data
# #     if (direction == "independent" && class(mygroup) == "factor" && class(mydep) == "factor") {
# #
# #             plotData <- data.frame(gr = mygroup,
# #                                    dp = mydep)
# #
# #
# #
# #             todo <- glue::glue(
# #                 "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         -
# #         -  "
# #             )
# #
# #
# #         }
# #
# #     # independent, continuous, factor ----
# #
# #     if (direction == "independent" && class(mygroup) %in% contin && class(mydep) == "factor") {
# #         todo <- glue::glue(
# #             "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         - Please switch the values: factor variable should be on x-axis and continuous variable should be on y-axis
# #         -  "
# #         )
# #
# #         stop("Please switch the values: factor variable should be on x-axis and continuous variable should be on y-axis")
# #         }
# #
# #
# #
# #     # repeated, factor, continuous ----
# #     # ggwithinstats 	violin plots 	for comparisons within groups/conditions
# #
# #
# #
# #     if (direction == "repeated" && class(mygroup) == "factor" && class(mydep) %in% contin) {
# #             plotData <- data.frame(gr = mygroup,
# #                                    dp = jmvcore::toNumeric(mydep))
# #
# #
# #
# #             todo <- glue::glue(
# #                 "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         -
# #         -  "
# #             )
# #
# #
# #             }
# #
# #
# #     # repeated, continuous, continuous ----
# #     # rmcorr::rmcorr()
# #
# #
# #     if (direction == "repeated" && class(mygroup) %in% contin && class(mydep) %in% contin) {
# #         todo <- glue::glue(
# #             "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         - Currently this module does not support repeated measures correlation.
# #         -  "
# #         )
# #
# #
# #         stop("Currently this module does not support repeated measures correlation.")
# #
# #     }
# #
# #
# #     # repeated, factor, factor ----
# #     # http://corybrunson.github.io/ggalluvial/
# #
# #     if (direction == "repeated" && class(mygroup) == "factor" && class(mydep) == "factor") {
# #             plotData <- data.frame(gr = mygroup,
# #                                    dp = mydep)
# #
# #
# #
# #             todo <- glue::glue(
# #                 "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         -
# #         -  "
# #             )
# #         }
# #
# #     # repeated, continuous, factor ----
# #
# #     if (direction == "repeated" && class(mygroup) %in% contin && class(mydep) == "factor") {
# #
# #         todo <- glue::glue(
# #             "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         - Please switch the values: factor variable should be on x-axis and continuous variable should be on y-axis
# #         -  "
# #         )
# #
# #
# #         stop("Please switch the values: factor variable should be on x-axis and continuous variable should be on y-axis")
# #
# #
# #     }
# 
# 
# 
# 
# 
# # Results ----
# 
# 
# 
# # Send Data to Plot ----
# 
# # plotData <- jmvcore::naOmit(plotData)
# # image <- self$results$plot
# # image$setState(plotData)
# 
# 
# # }
# 
# 
# # ,
# #
# # .plot = function(image, ...) {  # <-- the plot function ----
# #
# #
# #     if (is.null(self$options$dep) || is.null(self$options$group))
# #         return()
# #
# #
# #     plotData <- image$state
# #
# #     direction <- self$options$direction
# #
# #     mydata <- self$data
# #
# #     mydep <- self$data[[self$options$dep]]
# #
# #     mygroup <- self$data[[self$options$group]]
# #
# #     contin <- c("integer", "numeric", "double")
# #     categ <- c("factor")
# #
# #     # independent, factor, continuous ----
# #     # ggbetweenstats 	violin plots 	for comparisons between groups/conditions
# #
# #     if (direction == "independent" && class(mygroup) == "factor" && class(mydep) %in% contin) {
# #
# #             plot <- ggstatsplot::ggbetweenstats(
# #                 data = plotData,
# #                 x = gr,
# #                 y = dp
# #             )
# #         }
# #
# #     # independent, continuous, continuous ----
# #     # ggscatterstats 	scatterplots 	for correlations between two variables
# #
# #
# #         if (direction == "independent" && class(mygroup) %in% contin && class(mydep) %in% contin) {
# #
# #             plot <- ggstatsplot::ggscatterstats(
# #                 data = plotData,
# #                 x = gr,
# #                 y = dp
# #             )
# #
# #         }
# #
# #     # independent, factor, factor ----
# #     # ggbarstats 	bar charts 	for categorical data
# #
# #
# #     if (direction == "independent" && class(mygroup) == "factor" && class(mydep) == "factor") {
# #
# #
# #
# #             plot <- ggstatsplot::ggbarstats(
# #                                     data = plotData,
# #                                     main = gr,
# #                                     condition = dp
# #                                 )
# #         }
# #
# #     # repeated, factor, continuous ----
# #     # ggwithinstats 	violin plots 	for comparisons within groups/conditions
# #
# #
# # if (direction == "repeated" && class(mygroup) == "factor" && class(mydep) %in% contin) {
# #
# #
# #             plot <- ggstatsplot::ggwithinstats(
# #                 data = plotData,
# #                 x = gr,
# #                 y = dp
# #             )
# #
# #         }
# #
# #     # repeated, continuous, continuous ----
# #     # rmcorr::rmcorr()
# #
# #             # my.rmc <- rmcorr::rmcorr(participant = Subject,
# #             #                          measure1 = PacO2,
# #             #                          measure2 = pH,
# #             #                          dataset = rmcorr::bland1995)
# #             #
# #             # plot(my.rmc, overall = TRUE)
# #             #
# #             # ggplot2::ggplot(rmcorr::bland1995,
# #             #                 ggplot2::aes(x = PacO2,
# #             #                              y = pH,
# #             #                              group = factor(Subject),
# #             #                              color = factor(Subject)
# #             #                 )
# #             # ) +
# #             #     ggplot2::geom_point(ggplot2::aes(colour = factor(Subject))) +
# #             #     ggplot2::geom_line(ggplot2::aes(y = my.rmc$model$fitted.values), linetype = 1)
# #
# #
# #
# #     # repeated, factor, factor ----
# #     # http://corybrunson.github.io/ggalluvial/
# #     # networkD3
# #
# #
# #     if (direction == "repeated" && class(mygroup) == "factor" && class(mydep) == "factor") {
# #
# #
# #             mydata_changes <- plotData %>%
# #                 dplyr::group_by(gr, dp) %>%
# #                 dplyr::tally(x = .)
# #
# #
# #             # head(as.data.frame(UCBAdmissions), n = 12)
# #
# #             # ggalluvial::is_alluvia_form(
# #             #     as.data.frame(UCBAdmissions),
# #             #     axes = 1:3, silent = TRUE)
# #
# #
# #
# #             # plot <- ggplot(as.data.frame(UCBAdmissions),
# #             #        aes(y = Freq, axis1 = Gender, axis2 = Dept)) +
# #             #     geom_alluvium(aes(fill = Admit), width = 1/12) +
# #             #     geom_stratum(width = 1/12, fill = "black", color = "grey") +
# #             #     geom_label(stat = "stratum", infer.label = TRUE) +
# #             #     scale_x_discrete(limits = c("Gender", "Dept"), expand = c(.05, .05)) +
# #             #     scale_fill_brewer(type = "qual", palette = "Set1") +
# #             #     ggtitle("UC Berkeley admissions and rejections, by sex and department")
# #
# #
# #
# #
# #
# #             stratum <- ggalluvial::StatStratum
# #
# #             plot <- ggplot2::ggplot(data = mydata_changes,
# #                                     ggplot2::aes(axis1 = gr,
# #                        axis2 = dp,
# #                        y = n)) +
# #                 ggplot2::scale_x_discrete(limits = c(self$options$group, self$options$dep),
# #                                  expand = c(.1, .05)
# #                 ) +
# #                 ggplot2::xlab(self$options$group) +
# #                 ggalluvial::geom_alluvium(ggplot2::aes(fill = gr,
# #                                   colour = gr
# #                 )) +
# #                 ggalluvial::geom_stratum() +
# #                 ggalluvial::stat_stratum(geom = "stratum") +
# #                 ggplot2::geom_label(stat = stratum, infer.label = TRUE) +
# #
# #                 # ggalluvial::geom_stratum(stat = "stratum", label.strata = TRUE) +
# #                 # ggplot2::geom_text(stat = "stratum", infer.label = TRUE) +
# #                 # ggplot2::geom_text(label.strata = TRUE) +
# #                 # ggalluvial::geom_stratum()
# #                 ggplot2::theme_minimal()
# #                 # ggplot2::ggtitle(paste0("Changes in ", self$options$group))
# #             #
# #             #
# #             # nodes = data.frame("name" =
# #             #                        c(self$options$group,
# #             #                          self$options$dep))
# #             #
# #             # links <- mydata_changes
# #             #
# #             # names(links) = c("source", "target", "value")
# #             #
# #             # plot <- networkD3::sankeyNetwork(Links = links, Nodes = nodes,
# #             #               Source = "source", Target = "target",
# #             #               Value = "value", NodeID = "name",
# #             #               fontSize= 12, nodeWidth = 30)
# #
# #             # library(networkD3)
# #             # nodes = data.frame("name" =
# #             #                        c("Node A", # Node 0
# #             #                          "Node B", # Node 1
# #             #                          "Node C", # Node 2
# #             #                          "Node D"))# Node 3
# #             # links = as.data.frame(matrix(c(
# #             #     0, 1, 10, # Each row represents a link. The first number
# #             #     0, 2, 20, # represents the node being conntected from.
# #             #     1, 3, 30, # the second number represents the node connected to.
# #             #     2, 3, 40),# The third number is the value of the node
# #             #     byrow = TRUE, ncol = 3))
# #             # names(links) = c("source", "target", "value")
# #             # sankeyNetwork(Links = links, Nodes = nodes,
# #             #               Source = "source", Target = "target",
# #             #               Value = "value", NodeID = "name",
# #             #               fontSize= 12, nodeWidth = 30)
# #
# #             # plot <- c("Under Construction")
# #
# #             # plot <- list(plot1,
# #             #              plot2)
# #
# #
# #
# #         }
# #
# #
# #
# #     print(plot)
# #     TRUE
# #
# # }
# #
# #         )
# # )
```














---

# Packages


Imports: 
    jmvcore (>= 0.8.5),
    R6,
    dplyr,
    survival,
    survminer,
    finalfit,
    arsenal,
    purrr,
    glue,
    janitor,
    ggplot2,
    forcats,
    ggstatsplot,
    tableone,
    explore,
    tangram,
    irr,
    rlang,
    tidyselect,
    knitr



Remotes:
    easystats/correlation,
    neuropsychology/psycho.R@0.4.0


Suggests:
    rmarkdown,
    remotes,
    devtools,
    lubridate,
    broom, 
    GGally, 
    gridExtra, 
    Hmisc, 
    lme4, 
    magrittr, 
    mice, 
    pillar, 
    pROC, 
    scales, 
    stringr, 
    tibble, 
    tidyr, 
    covr, 
    cmprsk, 
    readr, 
    rstan, 
    survey, 
    testthat, 
    backports, 
    generics, 
    assertthat, 
    pkgconfig, 
    Rcpp, 
    BH, 
    plogr, 
    ellipsis, 
    gtable, 
    progress, 
    RColorBrewer, 
    reshape, 
    digest, 
    lazyeval, 
    viridisLite, 
    withr, 
    Formula, 
    latticeExtra, 
    acepack, 
    data.table, 
    htmlTable, 
    viridis, 
    htmltools, 
    base64enc, 
    minqa, 
    nloptr, 
    RcppEigen, 
    mitml, 
    cli, 
    crayon, 
    fansi, 
    utf8, 
    vctrs, 
    farver, 
    labeling, 
    munsell, 
    lifecycle, 
    stringi, 
    ggpubr, 
    maxstat, 
    survMisc, 
    jsonlite, 
    rex, 
    evaluate, 
    highr, 
    markdown, 
    xfun, 
    hms, 
    clipr, 
    mime, 
    tinytex, 
    StanHeaders, 
    inline, 
    loo, 
    pkgbuild, 
    numDeriv, 
    mitools, 
    pkgload, 
    praise, 
    zeallot, 
    colorspace, 
    prettyunits, 
    checkmate, 
    htmlwidgets, 
    pan, 
    jomo, 
    ordinal, 
    ucminf, 
    ggrepel,
    ggsci, 
    cowplot, 
    ggsignif,
    polynom, 
    exactRankTests,
    mvtnorm, 
    KMsurv, 
    zoo, 
    km.ci,
    xtable,
    curl, 
    openssl, 
    askpass, 
    sys, 
    matrixStats,
    callr, 
    desc,
    rprojroot,
    processx, 
    ps, 
    DBI,
    png, 
    jpeg, 
    boot, 
    grid, 
    snakecase,
    caret,
    iterators,
    timeDate,
    foreach,
    plyr,
    ModelMetrics,
    nlme,
    reshape2,
    recipes,
    BradleyTerry2,
    e1071,
    earth,
    fastICA,
    gam,
    ipred,
    kernlab,
    klaR,
    MASS,
    ellipse,
    mda,
    mgcv,
    mlbench,
    MLmetrics,
    nnet,
    party,
    pls,
    proxy,
    randomForest,
    RANN,
    spls,
    subselect,
    pamr,
    superpc,
    Cubist,
    rpart,
    qgraph,
    nFactors,
    ppcor,
    rstanarm,
    MuMIn,
    blavaan,
    
    
    
    
    



# Develop



```{r library}
# install.packages('jmvtools', repos=c('https://repo.jamovi.org', 'https://cran.r-project.org'))

# jmvtools::check("C://Program Files//jamovi//bin")

# jmvtools::install(home = "C://Program Files//jamovi//bin")
# 
# jmvtools::install(pkg = "C://ClinicoPath", home = "C://Program Files//jamovi//bin")

# devtools::build(path = "C:\\ClinicoPathOutput")

# .libPaths(new = "C:\\ClinicoPathLibrary")

# devtools::build(path = "C:\\ClinicoPathOutput", binary = TRUE, args = c('--preclean'))

Sys.setenv(TZ = "Europe/Istanbul")

library("jmvtools")
```


```{r check, include=FALSE}
jmvtools::check()

# rhub::check_on_macos()

# rhub::check_for_cran()

# codemetar::write_codemeta()


devtools::check()

```

```{r eval=FALSE, include=FALSE}
# From CRAN
# install.packages("attachment")
# From github
# remotes::install_github("ThinkR-open/attachment")

# If you correctly called the package dependencies in the {roxygen2} skeleton, in your functions, in your Rmarkdown vignettes and in your tests, you only need to run attachment::att_to_description()just before devtools::check(). And that’s it, there is nothing else to remember !
attachment::att_to_description()

```




```{r pkgdown build, include=FALSE}
rmarkdown::render('/Users/serdarbalciold/histopathRprojects/ClinicoPath/README.Rmd',  encoding = 'UTF-8', knit_root_dir = '~/histopathRprojects/ClinicoPath', quiet = TRUE)

devtools::document()

pkgdown::build_site()
```


```{r git force push, include=FALSE}
# gitUpdateCommitPush
CommitMessage <- paste("updated on ", Sys.time(), sep = "")
wd <- getwd()
gitCommand <- paste("cd ", wd, " \n git add . \n git commit --message '", CommitMessage, "' --no-verify \n git push origin master \n", sep = "")
# gitCommand <- paste("cd ", wd, " \n git add . \n git commit --no-verify --message '", CommitMessage, "' \n git push origin master \n", sep = "")
system(command = gitCommand, intern = TRUE)

```



```{r add analysis, eval=FALSE, include=FALSE}

# jmvtools::install()
# 
# jmvtools::create('SuperAwesome')
# 
# jmvtools::addAnalysis(name='ttest', title='Independent Samples T-Test')
# 
# jmvtools::addAnalysis(name='survival', title='survival')
# 
# jmvtools::addAnalysis(name='correlation', title='correlation')
# 
# jmvtools::addAnalysis(name='tableone', title='TableOne')
# 
# jmvtools::addAnalysis(name='crosstable', title='CrossTable')
# 
# 
# jmvtools::addAnalysis(name='writesummary', title='WriteSummary')

# jmvtools::addAnalysis(name='finalfit', title='FinalFit')

# jmvtools::addAnalysis(name='multisurvival', title='FinalFit Multivariate Survival')

# jmvtools::addAnalysis(name='report', title='Report General Features')

# jmvtools::addAnalysis(name='frequencies', title='Frequencies')

# jmvtools::addAnalysis(name='statsplot', title='GGStatsPlot')

# jmvtools::addAnalysis(name='statsplot2', title='GGStatsPlot2')

# jmvtools::addAnalysis(name='statsplotbetween', title='Stats Plot Between')

# jmvtools::addAnalysis(name='competingsurvival', title='Competing Survival')


# jmvtools::addAnalysis(name='scat2', title='scat2')

# jmvtools::addAnalysis(name='decisioncalculator', title='Decision Calculator')

# jmvtools::addAnalysis(name='agreement', title='Interrater Intrarater Reliability')

# jmvtools::addAnalysis(name='cluster', title='Cluster Analysis')

# jmvtools::addAnalysis(name='tree', title='Decision Tree')
# 
# jmvtools::addAnalysis(name='oddsratio', title='Odds Ratio Table and Plot')

# jmvtools::addAnalysis(name='roc', title='ROC')

# jmvtools::addAnalysis(name = "icccoeff", title = "ICC coefficients")

# jmvtools::addAnalysis(name = "gtsummary", title = "Tables via gtsummary")

# jmvtools::addAnalysis(name = "alluvial", title = "Alluvial Diagrams")


```






```{r devtools install, eval=FALSE, include=FALSE}
Sys.unsetenv("R_PROFILE_USER")
devtools::check()

devtools::install()
```


```{r jmvtools install, eval=FALSE, include=FALSE}
# jmvtools::check()
jmvtools::install()
```



```{r construct formula}
formula <- jmvcore::constructFormula(terms = c("A", "B", "C"), dep = "D")

jmvcore::constructFormula(terms = list("A", "B", c("C", "D")), dep = "E")

jmvcore::constructFormula(terms = "A")


jmvcore::constructFormula(terms = list("A", "B", "C"))

vars <- jmvcore::decomposeFormula(formula = formula) 

unlist(vars)

cformula <- jmvcore::composeTerm(components = formula)

jmvcore::composeTerm("A")

jmvcore::composeTerm(components = c("A", "B", "C"))

jmvcore::decomposeTerm(term = c("A", "B", "C"))

jmvcore::decomposeTerm(term = formula)

jmvcore::decomposeTerm(term = cformula)



composeTerm <- jmvcore::composeTerm(components = c("A", "B", "C"))

jmvcore::decomposeTerm(term = composeTerm)


```





---


```{r read and write data, eval=FALSE, include=FALSE}
BreastCancer <- readr::read_csv(file = "/Users/serdarbalciold/histopathRprojects/ClinicoPath/data/BreastCancer.csv")

usethis::use_data(BreastCancer)

BreastCancer <- readr::read_csv(file = "/Users/serdarbalciold/histopathRprojects/ClinicoPath/data/BreastCancer.csv")

usethis::use_data(BreastCancer)

colon <- readr::read_csv(file = 
"/Users/serdarbalciold/histopathRprojects/ClinicoPath/data/colon.csv")

usethis::use_data(colon)


melanoma <- readr::read_csv(file = 
"/Users/serdarbalciold/histopathRprojects/ClinicoPath/data/melanoma.csv")

usethis::use_data(melanoma)


rocdata <- readr::read_csv(file = 
"/Users/serdarbalciold/histopathRprojects/ClinicoPath/data/rocdata.csv")

usethis::use_data(rocdata)

histopathology <- readr::read_csv(file = 
"/Users/serdarbalciold/histopathRprojects/ClinicoPath/data/histopathology.csv")

usethis::use_data(histopathology)


```



```{r}
data('histopathology')
dat <- as.data.frame(histopathology)
ClinicoPath::tableone(
data = dat,
vars = vars(Sex, PreinvasiveComponent, LVI, PNI, Grade, Age),
sty = "t2",
excl = TRUE)
```






---

# Example


```{r read data}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))
```


```{r}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

library(magrittr)

corx <- deneme %>%
                dplyr::select(Age, OverallTime) %>% 
                stats::cor(method = "spearman") %>%
                report::report()

```








```{r}
inherits(deneme$Sex, "character")
```

```{r}
ggstatsplot::ggbetweenstats(data = deneme,
                            x = Sex,
                            y = Age,
                            type = "p")

ClinicoPath::statsplot2(
    data = deneme,
    dep = Age,
    group = Sex)
```




```{r writesummary, eval=FALSE, include=FALSE}
devtools::install(upgrade = FALSE, quick = TRUE)
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

# library("ClinicoPath")

deneme$Age <- as.numeric(as.character(deneme$Age))

ClinicoPath::writesummary(data = deneme, vars = Age)

ggstatsplot::normality_message(deneme$Age, "Age")


ClinicoPath::writesummary(
    data = deneme,
    vars = Age)


```



```{r finalfit, eval=FALSE, include=FALSE}
devtools::install(upgrade = FALSE, quick = TRUE)
library(dplyr)
library(survival)
library(finalfit)
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))
ClinicoPath::finalfit(data = deneme,
                      explanatory = Sex,
                      outcome = Outcome,
                      overalltime = OverallTime)
```



```{r decision, eval=FALSE, include=FALSE}
devtools::install(upgrade = FALSE, quick = TRUE)
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

ClinicoPath::decision(
    data = deneme,
    gold = Outcome,
    goldPositive = "1",
    newtest = Smoker,
    testPositive = "TRUE")

ClinicoPath::decision(
    data = deneme,
    gold = LVI,
    goldPositive = "Present",
    newtest = PNI,
    testPositive = "Present")
```

```{r eval=FALSE, include=FALSE}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))
ggstatsplot::ggbetweenstats(data = deneme, 
                            x = LVI,
                            y = Age)

```





```{r statsplot, eval=FALSE, include=FALSE}
devtools::install(upgrade = FALSE, quick = TRUE)
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))
ClinicoPath::statsplot(
    data = deneme,
    dep = Age,
    group = Smoker)
```




```{r decision 2, eval=FALSE, include=FALSE}
mytable <- table(deneme$Outcome, deneme$Smoker)

caret::confusionMatrix(mytable)
confusionMatrix(pred, truth)
confusionMatrix(xtab, prevalence = 0.25)

levels(deneme$Outcome)

mytable[1,2]

d <- "0"

mytable[d, "FALSE"]

mytable[[0]]

```











```{r construct formula, eval=FALSE, include=FALSE}
formula <- jmvcore::constructFormula(terms = c("A", "B", "C"))

jmvcore::constructFormula(terms = list("A", "B", "C"))

vars <- jmvcore::decomposeFormula(formula = formula) 

vars <- jmvcore::decomposeTerms(vars)


vars <- unlist(vars)

formula <- as.formula(formula)


my_group <- "lvi"

jmvcore::composeTerm(my_group)


my_dep <- "age"

formula <- paste0('x = ', group, 'y = ', dep)
myformula <- as.formula(formula)

myformula <- glueformula::gf({my_group}, {my_dep})

myformula <- glue::glue( 'x = ' , {my_group}, ', y = ' , {my_dep})

myformula <- jmvcore::composeTerm(myformula)


```


```{r}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

library(survival)
km_fit <- survfit(Surv(OverallTime, Outcome) ~ LVI, data = deneme)

library(dplyr)
km_fit_median_df <- summary(km_fit)
km_fit_median_df <- as.data.frame(km_fit_median_df$table) %>%
                janitor::clean_names(dat = ., case = "snake") %>%
                tibble::rownames_to_column(.data = ., var = "LVI")

```



```{r construct formula 2, eval=FALSE, include=FALSE}
library(dplyr)
library(survival)

deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

myoveralltime <- deneme$OverallTime
myoutcome <- deneme$Outcome
myexplanatory <- deneme$LVI

class(myoveralltime)
class(myoutcome)
typeof(myexplanatory)

is.ordered(myexplanatory)

formula2 <- jmvcore::constructFormula(terms = "myexplanatory")
# formula2 <- jmvcore::decomposeFormula(formula = formula2)
# formula2 <- paste("", formula2)
# formula2 <- as.formula(formula2)
formula2 <- jmvcore::composeTerm(formula2)


formulaL <- jmvcore::constructFormula(terms = "myoveralltime")
# formulaL <- jmvcore::decomposeFormula(formula = formulaL)

formulaR <- jmvcore::constructFormula(terms = "myoutcome")
# formulaR <- jmvcore::decomposeFormula(formula = formulaR)

formula <- paste("Surv(", formulaL, ",", formulaR, ")")
# formula <- jmvcore::composeTerm(formula)
# formula <- as.formula(formula)
# jmvcore::constructFormula(terms = c(formula, formula2))

deneme %>%
  finalfit::finalfit(formula, formula2) -> tUni

tUni
```


```{r eval=FALSE, include=FALSE}
library(dplyr)
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

results <- deneme %>%
                ggstatsplot::ggbetweenstats(LVI, Age)
results

mydep <- deneme$Age
mygroup <- deneme$LVI


mygroup <- jmvcore::constructFormula(terms = "mygroup")
mygroup <- jmvcore::composeTerm(mygroup)

mydep <- jmvcore::constructFormula(terms = "mydep")
mydep <- jmvcore::composeTerm(mydep)


# not working
# eval(mygroup)
# rlang::eval_tidy(mygroup)
# !!mygroup
# {{mygroup}}
# sym(mygroup)
# quote(mygroup)
# enexpr(mygroup)

mygroup <- jmvcore::constructFormula(terms = "mygroup")
mydep <- jmvcore::constructFormula(terms = "mydep")

formula1 <- paste(mydep)
formula1 <- jmvcore::composeTerm(formula1)


mygroup <- paste(mygroup)
mygroup <- jmvcore::composeTerm(mygroup)

mydep <- deneme$Age
mygroup <- deneme$LVI

mydep <- jmvcore::resolveQuo(jmvcore::enquo(mydep))
mygroup <- jmvcore::resolveQuo(jmvcore::enquo(mygroup))

mydata2 <- data.frame(mygroup=mygroup, mydep=mydep)

results <- mydata2 %>%
                ggstatsplot::ggbetweenstats(
x = mygroup, y = mydep  )

results



myformula <- glue::glue('x = ', {mygroup}, ', y = ' , {mydep})

myformula <- jmvcore::composeTerm(myformula)

myformula <- as.formula(myformula)
















mydep2 <- quote(mydep)
mygroup2 <- quote(mygroup)


results <- deneme %>%
                ggstatsplot::ggbetweenstats(!!mygroup2, !!mydep2)
results
```








```{r construct formula 3, eval=FALSE, include=FALSE}
formula <- jmvcore::constructFormula(terms = c("myoveralltime", "myoutcome"))

vars <- jmvcore::decomposeFormula(formula = formula) 


explanatory <- jmvcore::constructFormula(terms = c("explanatory"))    

explanatory <- jmvcore::decomposeFormula(formula = explanatory)

explanatory <- unlist(explanatory)

myformula <- paste("Surv(", vars[1], ", ", vars[2], ")")



deneme %>%
finalfit::finalfit(myformula, explanatory) -> tUni

```


```{r table tangram}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))


table3 <-
  tangram::html5(
    tangram::tangram(
      "Death ~ LVI + PNI + Age", deneme),
    fragment=TRUE,
    # style = "hmisc",
    style = "nejm",
    # inline="nejm.css",
    caption = "HTML5 Table",
    id="tbl3")

table3

mydep <- deneme$Age
mygroup <- deneme$Death


formulaR <- jmvcore::constructFormula(terms =  c("LVI", "PNI", "Age"))

formulaL <- jmvcore::constructFormula(terms = "Death")

formula <- paste(formulaL, '~', formulaR)

# formula <- as.formula(formula)

sty <- jmvcore::composeTerm(components = "nejm")

gr <- jmvcore::composeTerm(components = "Death")


table <- tangram::html5(
    tangram::tangram(formula, deneme
                     ),
    fragment=TRUE,
    # style = "hmisc",
    # style = "nejm",
    style = sty,
    # inline="nejm.css",
    caption = paste0("HTML5 Table ", gr),
    id="tbl4")

table


```





```{r read data OR}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))


mydata <- deneme

formula2 <- jmvcore::constructFormula(terms = c("LVI", "PNI", "Age"))

formulaR <- jmvcore::constructFormula(terms = "Death")

formulaR <- jmvcore::toNumeric(formulaR)



plot <-
                finalfit::or_plot(
                    .data = mydata,
                    dependent = formulaR,
                    explanatory = formula2,
                    remove_ref = FALSE,
                    table_text_size = 4,
                    title_text_size = 14,
                    random_effect = NULL,
                    factorlist = NULL,
                    glmfit = NULL,
                    confint_type = NULL,
                    breaks = NULL,
                    column_space = c(-0.5, 0, 0.5),
                    dependent_label = "Death",
                    prefix = "",
                    suffix = ": OR (95% CI, p-value)",
                    table_opts = NULL,
                    plot_opts = list(
                    ggplot2::xlab("OR, 95% CI"),
                    ggplot2::theme(
                    axis.title = ggplot2::element_text(size = 12)
                    )
                    )
                    )


```







---

# Other Codes

## force git

```{r force git, eval=FALSE, include=FALSE}
# gitUpdateCommitPush
CommitMessage <- paste("updated on ", Sys.time(), sep = "")
wd <- getwd()
gitCommand <- paste("cd ", wd, " \n git add . \n git commit --message '", CommitMessage, "' \n git push origin master \n", sep = "")
system(command = gitCommand, intern = TRUE)

```


## arsenal

```{r arsenal, results='asis'}

tab1 <- arsenal::tableby(~ Age + Sex, data = deneme)

results <- summary(tab1)


# results$object
# results$control
# results$totals
# results$hasStrata
# results$text
# results$pfootnote
# results$term.name
# 
# tab1$Call
# 
# tab1$control

tab1$tables # this is where results lie


```


## define survival time

```{r define survival time, eval=FALSE, include=FALSE}
mydata$int <- lubridate::interval(
  lubridate::ymd(mydata$SurgeryDate),
  lubridate::ymd(mydata$LastFollowUpDate)
  )
mydata$OverallTime <- lubridate::time_length(mydata$int, "month")
mydata$OverallTime <- round(mydata$OverallTime, digits = 1)
```




## Multivariate Analysis Survival


```{r Multivariate Analysis, eval=FALSE, include=FALSE}
library(finalfit)
library(survival)
explanatoryMultivariate <- explanatoryKM
dependentMultivariate <- dependentKM

mydata %>%
  finalfit(dependentMultivariate, explanatoryMultivariate) -> tMultivariate

knitr::kable(tMultivariate, row.names=FALSE, align=c("l", "l", "r", "r", "r", "r"))
```


---

```{r}
# Find arguments in yaml

list_of_yaml <- c(
    list.files(path = "~/histopathRprojects/ClinicoPath-Jamovi--prep/jmv",
               pattern = "\\.yaml$",
               full.names = TRUE,
               all.files = TRUE,
               include.dirs = TRUE,
               recursive = TRUE
    )
)


text_of_yaml_yml <- purrr::map(
    .x = list_of_yaml,
    .f = readLines
)

text_of_yaml_yml <- as.vector(unlist(text_of_yaml_yml)) 

arglist <-
    stringr::str_extract(
        string = text_of_yaml_yml, 
        pattern = 
            "([[:alnum:]]*):"
    )

arglist <- arglist[!is.na(arglist)]
arglist <- unique(arglist)
arglist <- gsub(pattern = ":", # remove some characters
                    replacement = "",
                    x = arglist)
arglist <- trimws(arglist) # remove whitespace

cat(arglist, sep = "\n")

```






<!-- # -->
<!-- #                 # tUni_df_descr <- paste0("When ", -->
<!-- #                 #                         tUni_df$dependent_surv_overall_time_outcome[1], -->
<!-- #                 #                         " is ", -->
<!-- #                 #                         tUni_df$x[2], -->
<!-- #                 #                         ", there is ", -->
<!-- #                 #                         tUni_df$hr_univariable[2], -->
<!-- #                 #                         " times risk than ", -->
<!-- #                 #                         "when ", -->
<!-- #                 #                         tUni_df$dependent_surv_overall_time_outcome[1], -->
<!-- #                 #                         " is ", -->
<!-- #                 #                         tUni_df$x[1], -->
<!-- #                 #                         "." -->
<!-- #                 # ) -->
<!-- # -->
<!-- #                 # results5 <- tUni_df_descr -->


```{r}
boot::melanoma
rio::export(x = boot::melanoma, file = "data/melanoma.csv")

survival::colon
rio::export(x = survival::colon, file = "data/colon.csv")

# BreastCancerData <- "https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data"
# 
# BreastCancerNames <- "https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.names"
# 
# BreastCancerData <- read.csv(file = BreastCancerData, header = FALSE,
#                 col.names = c("id","CT", "UCSize", "UCShape", "MA", "SECS", "BN", "BC", "NN","M", "diagnosis") )

library(mlbench)

data("BreastCancer")
BreastCancer

rio::export(x = BreastCancer, file = "data/BreastCancer.csv")



```




```{r pairwise}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))
# names(deneme)

mypairwise <-  survminer::pairwise_survdiff(
                            formula = survival::Surv(OverallTime, Outcome) ~ TStage,
                            data = deneme,
                            p.adjust.method = "BH"
                            )


mypairwise2 <- as.data.frame(mypairwise[["p.value"]]) %>% 
  tibble::rownames_to_column()

mypairwise2 %>% 
  tidyr::pivot_longer(cols = -rowname) %>% 
  dplyr::filter(complete.cases(.)) %>% 
  dplyr::mutate(description =
                            glue::glue(
                                "The comparison between {rowname} and {name} has a p-value of {round(value, 2)}."
                            )
                    ) %>% 
                    dplyr::select(description) %>%
                    dplyr::pull() -> mypairwisedescription

mypairwisedescription <- unlist(mypairwisedescription)

mypairwisedescription <- c(
"In the pairwise comparison of",
mypairwisedescription)




```



```{r}
            # mydata <- self$data

            # mydep <- self$data[[self$options$dep]]
            # mygroup <- self$data[[self$options$group]]
            #
            #
            # plotData <- data.frame(gr = mygroup, dp = jmvcore::toNumeric(mydep))
            # plotData <- jmvcore::naOmit(plotData)
            #
            # image <- self$results$plot
            #
            # image$setState(plotData)


            # self$results$text1$setContent(plotData)


            # mydepType <- data.frame(vclass = class(mydep),
            #                         vtypeof = typeof(mydep),
            #                         vordered = is.ordered(mydep),
            #                         vfactor = is.factor(mydep),
            #                         vnumeric = is.numeric(mydep),
            #                         vdouble = is.double(mydep),
            #                         vcharacter = is.character(mydep),
            #                         vdate = lubridate::is.Date(mydep),
            #                         vdate2 = is.na.POSIXlt(mydep)
            #                         )
            # mygroupType <- class(mygroup)
            # variableTypes <- list(mydepType, mygroupType)
            # self$results$text1$setContent(variableTypes)

            # plotData <- image$state


            # https://indrajeetpatil.github.io/ggstatsplot/
            # ggbetweenstats 	violin plots 	for comparisons between groups/conditions
            # ggwithinstats 	violin plots 	for comparisons within groups/conditions
            #
            # ggdotplotstats 	dot plots/charts 	for distribution about labeled numeric variable
            #
            # ggbarstats 	bar charts 	for categorical data
            #
            # ggscatterstats 	scatterplots 	for correlations between two variables

            # http://corybrunson.github.io/ggalluvial/


            # plot <- ggplot(plotData, aes(x = gr,
            #                              y = dp)) +
            #     geom_point()

            # plot <- plotData %>%
            #     ggstatsplot::ggbetweenstats(
            #         x = gr,
            #         y = dp
            #         )
```




```{r read csv}
library(readr)
BreastCancer <- read_csv("data/BreastCancer.csv")
View(BreastCancer)
```





```{r}


mytarget <- "Class"
myvars <- c("Cl.thickness",
            "Cell.size",
            "Cell.shape",
            "Marg.adhesion",
            "Epith.c.size",
            "Bare.nuclei",
            "Bl.cromatin",
            "Normal.nucleoli",
            "Mitoses")

mydata <- BreastCancer %>% 
    select(mytarget, myvars)

formula <- jmvcore::constructFormula(terms = mytarget)

formula <- paste(formula, '~ .')

formula <- as.formula(formula)

 # Create an FFTrees object from the data
 FFTrees.fft <- FFTrees::FFTrees(
     formula = formula,
     data = mydata
     )

 # Plot the best tree applied to the test data
 plot2 <- plot(FFTrees.fft,
      data = mydata
      # ,
      # main = "Heart Disease",
      # decision.labels = c("Healthy", "Disease")
                 )
```





```{r}
devtools::install(upgrade = FALSE, quick = TRUE)


deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))


ClinicoPath::statsplotbetween(
    data = deneme,
    dep = LVI,
    group = PNI)
```


```{r}
myirr <- data.frame(
          Rater1 = c(0L,1L,1L,0L,0L,0L,1L,1L,1L,0L,1L,
                 1L,1L,1L,1L,0L,NA,1L,1L,0L,0L,1L,1L,1L,1L,1L,0L,
                 1L,1L,1L,1L,0L,1L,1L,1L,1L,1L,0L,0L,1L,1L,1L,
                 1L,1L,0L,1L,1L,1L,0L,0L,1L,1L,1L,0L,1L,1L,1L,0L,
                 1L,1L,0L,1L,0L,1L,1L,0L,0L,1L,0L,1L,1L,1L,0L,0L,
                 0L,0L,1L,1L,1L,0L,0L,1L,1L,1L,1L,0L,0L,0L,1L,0L,
                 0L,1L,1L,0L,1L,1L,0L,1L,1L,0L,1L,1L,0L,1L,1L,
                 0L,1L,1L,1L,0L,1L,1L,1L,0L,1L,1L,0L,0L,1L,0L,1L,
                 1L,1L,0L,1L,1L,1L,1L,1L,1L,1L,1L,0L,1L,1L,1L,1L,
                 1L,1L,1L,1L,1L,1L,0L,1L,1L,1L,1L,1L,1L,1L,0L,0L,
                 1L,0L,1L,1L,1L,1L,1L,0L,0L,1L,1L,1L,1L,1L,0L,
                 0L,0L,1L,1L,0L,1L,1L,0L,1L,0L,1L,1L,1L,0L,1L,1L,
                 1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,
                 0L,0L,1L,1L,1L,1L,0L,0L,1L,1L,0L,1L,1L,1L,0L,1L,
                 0L,1L,1L,1L,1L,0L,0L,0L,0L,1L,0L,1L,1L,1L,0L,
                 0L,1L,1L,1L,0L,1L,0L,0L,0L,1L,1L,1L,0L,1L,0L,0L,
                 0L,1L,1L),
          Rater2 = c(0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,
                 0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,1L,1L,1L,0L,
                 1L,1L,1L,1L,0L,1L,1L,1L,1L,1L,0L,0L,1L,1L,1L,
                 1L,1L,0L,1L,1L,1L,0L,0L,1L,1L,1L,0L,1L,1L,1L,0L,
                 1L,1L,0L,1L,0L,1L,1L,0L,0L,1L,0L,1L,1L,1L,0L,0L,
                 0L,0L,1L,1L,1L,0L,0L,1L,1L,1L,1L,0L,0L,0L,1L,0L,
                 0L,1L,1L,0L,1L,1L,0L,1L,1L,0L,1L,1L,0L,1L,1L,
                 0L,1L,1L,1L,0L,1L,1L,1L,0L,1L,1L,0L,0L,1L,0L,1L,
                 1L,1L,0L,1L,1L,1L,1L,1L,1L,1L,1L,0L,1L,1L,1L,1L,
                 1L,1L,1L,1L,1L,1L,0L,1L,1L,1L,1L,1L,1L,1L,0L,0L,
                 1L,0L,1L,1L,1L,1L,1L,0L,0L,1L,1L,1L,1L,1L,0L,
                 0L,0L,1L,1L,0L,1L,1L,0L,1L,0L,1L,1L,1L,0L,1L,1L,
                 1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,
                 0L,0L,1L,1L,1L,1L,0L,0L,1L,1L,0L,1L,1L,1L,1L,1L,
                 1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,0L,1L,1L,1L,0L,
                 0L,1L,1L,1L,0L,1L,0L,0L,0L,1L,1L,1L,0L,1L,0L,0L,
                 0L,1L,1L)
)

myirr <- myirr %>% 
    dplyr::mutate(
        RaterA = dplyr::case_when(
            Rater1 == 0 ~ "Negative",
            Rater1 == 1 ~ "Positive"
        )
    ) %>% 
    dplyr::mutate(
        RaterB = dplyr::case_when(
            Rater2 == 0 ~ "Negative",
            Rater2 == 1 ~ "Positive"
        )
    ) %>% 
    dplyr::select(RaterA, RaterB) %>% 
    mutate(RaterA = as.factor(RaterA)) %>% 
    mutate(RaterB = as.factor(RaterB))

table <- myirr %$% 
table(RaterA, RaterB)

mymatrix <- caret::confusionMatrix(table, positive = "Positive")
mymatrix

caret::sensitivity(table, positive = "Positive")


mymatrix2 <- caret::confusionMatrix(table, positive = "Positive", prevalence = 0.25)
mymatrix2


```


```{r epiR}
 dat <- as.table(
                matrix(c(670,202,74,640),
                       nrow = 2,
                       byrow = TRUE)
                )

            colnames(dat) <- c("Dis+","Dis-")
            rownames(dat) <- c("Test+","Test-")

            rval <- epiR::epi.tests(dat, conf.level = 0.95)

            rval <- list(
                dat,
                rval,
                print(rval),
                summary(rval)
                         )
```


```{r irr agreement}
devtools::install(upgrade = FALSE, quick = TRUE)
library(dplyr)

deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

ratings <- deneme %>% 
    dplyr::select(LVI, PNI, Age, ID)


f <- unlist(lapply(ratings, class))

any(f == "numeric")

all(f == "numeric")


xtitle <- names(ratings)[1]
ytitle <- names(ratings)[2]

result <- table(ratings[,1], ratings[,2],
                dnn = list(xtitle, ytitle))

table(ratings)



result1 <- irr::agree(ratings)


result2 <- irr::kappa2(ratings)


ClinicoPath::agreement(
    data = deneme,
    vars = c(LVI,PNI)
)


result2 <- irr::kappam.fleiss(
                    ratings = ratings,
                    exact = FALSE,
                    detail = TRUE)



```




```{r}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

mytree <- vtree::vtree(deneme, "LVI PNI")

# write(mytree[["x"]][["diagram"]], 
#       file = here::here("/tododata/trial1.gv"))

# DiagrammeR::grViz(diagram = here::here("/tododata/trial1.gv"))

diagram <- mytree[["x"]][["diagram"]]

mytree2 <- DiagrammeR::grViz(diagram = diagram)


print(mytree2)

```









# Packages for Development



---


## rpkgtools


devtools::install_github("IndrajeetPatil/rpkgtools")



## available


Check if a package name is available to use https://docs.ropensci.org/available


https://github.com/r-lib/available


```{r eval=FALSE, include=FALSE}
available::available("clinicopath")
available::available("lens2r")

```



## bench


High Precision Timing of R Expressions http://bench.r-lib.org/

https://github.com/r-lib/bench






## desc


Manipulate DESCRIPTION files
https://github.com/r-lib/desc



## pkgverse

pkgverse: Build a Meta-Package Universe
https://pkgverse.mikewk.com/



## pkgbuild

pkgbuild: Find Tools Needed to Build R Packages
https://github.com/r-lib/pkgbuild


## pkgload

pkgload: Simulate Package Installation and Attach
https://github.com/r-lib/pkgload


## rcmdcheck

rcmdcheck: Run 'R CMD check' from 'R' and Capture Results
https://github.com/r-lib/rcmdcheck




## remotes


## sessioninfo

Print Session Information

https://github.com/r-lib/sessioninfo



## "covr




## "exampletestr


## "covrpage",


## "gramr",


## "lintr",


## "goodpractice",


## "pkgdown",


## "usethis",


## "testthat",


## "spelling",


## "RTest",

https://towardsdatascience.com/rtest-pretty-testing-of-r-packages-50f50b135650


## "rhub",


## "roxygen2",


## "sinew",


## "styler",



## "vdiffr"




## "attachment (https://github.com/ThinkR-open/attachment)
## "covrpage (https://github.com/yonicd/covrpage)
## "defender (https://github.com/ropenscilabs/defender)
## "gramr (https://github.com/ropenscilabs/gramr)
## "packagemetrics (https://github.com/ropenscilabs/packagemetrics)
## "pRojects (https://github.com/lockedata/pRojects)
## "revdepcheck (https://github.com/r-lib/revdepcheck)
## "roxygen2Comment (https://github.com/csgillespie/roxygen2Comment)
## "roxygen2md (https://github.com/r-lib/roxygen2md)
## "testdown (https://github.com/ThinkR-open/testdown)
## "tic (https://github.com/ropenscilabs/tic)





---



```{r}
            # Table1 <- table(mydata[[testVariable]], mydata[[goldVariable]])


            # Table1 <- mydata %>%
            #     janitor::tabyl(.data[[testVariable]], .data[[goldVariable]]) %>%
            #     janitor::adorn_totals(dat = ., where = c("row", "col")) %>%
            #     janitor::adorn_percentages(dat = ., denominator = "row") %>%
            #     janitor::adorn_percentages(dat = ., denominator = "col") %>%
            #     janitor::adorn_pct_formatting(dat = ., rounding = "half up", digits = 1) %>%
            #     janitor::adorn_ns(dat = .) %>%
            #     janitor::adorn_title("combined")
            # results1 <- Table1
```


```{r}
                # results1 <- summary(km_fit)$table

                # km_fit_median_df <- summary(km_fit)
                # km_fit_median_df <- as.data.frame(km_fit_median_df$table) %>%
                #     janitor::clean_names(dat = ., case = "snake") %>%
                #     tibble::rownames_to_column(.data = .)

                # results1 <- tibble::as_tibble(results1,
                #                              .name_repair = "minimal") %>%
                #     janitor::clean_names(dat = ., case = "snake") %>%
                #     tibble::rownames_to_column(.data = ., var = self$options$explanatory)
```

```{r update project for release}

readyfunctions <- c(
    "refs",
    # "^agreement",
    # "^competingsurvival",
    # "^correlation",
    # "^crosstable",
    # "^decision",
    # "^decisioncalculator",
    # "^icccoeff",
    # "^multisurvival",
    # "^oddsratio",
    # "^pairchi2",
    # "^reportcat",
    # "^roc",
    # "^statsplot2",
    # "^summarydata",
    # "^survival",
    # "^tableone"
    # "^tree",
    # "^utils-pipe"
    # "^vartree"
)





readyfunctions <- paste0(readyfunctions, collapse = "|")

files_R <-
    list.files(path = here::here("R"),
               pattern = readyfunctions,
               full.names = TRUE)

files_jamovi <-
    list.files(
        path = here::here("jamovi"),
        pattern = readyfunctions,
        full.names = TRUE
    )

file.copy(from = files_R,
          to = "~/ClinicoPath/R/",
          overwrite = TRUE)


file.copy(from = files_jamovi,
          to = "~/ClinicoPath/jamovi/",
          overwrite = TRUE)

```

```{r decision}

table2 <- matrix(c(80, 20, 30, 70), nrow = 2, ncol = 2, byrow = TRUE, dimnames = list(c("Positive", "Negative"), c("Positive","Negative")))

            table3 <- as.table(table2)

            names(attributes(table3)$dimnames) <- c("Test","Gold Standart")

caretresult <- caret::confusionMatrix(table3, mode = "everything")




```


```{r}
table3 <- matrix(c(80L, 20L, 25L, 30L, 70L, 75L), nrow = 2, ncol = 3, byrow = TRUE)


# RVAideMemoire::chisq.multcomp() RVAideMemoire::fisher.multcomp()

result1 <- RVAideMemoire::chisq.multcomp(table3)

result1 <- result1[["p.value"]]


result1 <- as.data.frame(result1) %>%
                                tibble::rownames_to_column()

result1 <- result1 %>%
    tidyr::pivot_longer(cols = -rowname) %>%
    dplyr::filter(complete.cases(.))




myfun <- function(i,j) {
    if(!is.na(result1[i,j])){
    paste0(    
dimnames(result1)[[1]][i],
" vs ",
dimnames(result1)[[2]][j],
" p= ",    
result1[i,j])
    }
}

for (i in 1:dim(result1)[1]) {
for (j in 1:dim(result1)[2]) {
    des <- myfun(i,j)
    if(!is.null(des)) print(des)
}
}


myfun1 <- function(i,j) {
    if(!is.na(result1[i,j])){
dimnames(result1)[[1]][i]
    }
}


for (i in 1:dim(result1)[1]) {
for (j in 1:dim(result1)[2]) {
    des <- myfun1(i,j)
    if(!is.null(des)) print(des)
}
}





myfun(3,3)

myfun(1,2)


dimnames(result1)[[1]][2]


RVAideMemoire::fisher.multcomp(table3)


# rmngb::pairwise.chisq.test(x, ...)  rmngb::pairwise.fisher.test(x, ...)


library(rmngb)
x <- sample(1:2, 1e3, TRUE)
g <- sample(1:4, 1e3, TRUE)
result2 <- rmngb::pairwise.chisq.test(x, g)
tab <- table(g, x)

resultrmngb <- rmngb::pairwise.fisher.test(tab, p.adj = "bonf")

result2[["p.value"]]
resultrmngb[["p.value"]]

rmngb::pairwise.chisq.test(tab)


```



 
formula <- jmvcore::constructFormula(terms = self$options$vars)
formula <- paste('~', formula)
formula <- as.formula(formula)
table1 <- arsenal::tableby(formula, self$data,
total = TRUE,
digits = 1,
digits.count = 1
)
myarsenal <- summary(table1, text = "html")
myarsenal <- kableExtra::kable(myarsenal, format = "html",
digits = 1,
escape = TRUE) %>%
kableExtra::kable_styling(kable_input = .,
bootstrap_options = "striped",
full_width = F,
position = "left")


```{r}
library(dplyr)

deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))


varsName <- c("LVI", "PNI")

tablelist <- list()

                for (i in 1:length(varsName)) {

                    var <- varsName[i]
                    
                    
                    table <- deneme %>%
                        janitor::tabyl(dat = ., var) %>%
                        janitor::adorn_totals("row") %>%
                        janitor::adorn_pct_formatting(dat = .)

                    tablelist[[i]] <- table

                }

tablelist

```





            data <- self$data

            vars <- self$options$vars

            facs <- self$options$facs

            target <- self$options$target

            # data <- jmvcore::select(data, c(vars, facs, target))


            if ( ! is.null(vars))
            for (var in vars)
                data[[var]] <- jmvcore::toNumeric(data[[var]])

            if ( ! is.null(facs))
            for (fac in facs)
                data[[fac]] <- as.factor(data[[fac]])


            data[[target]] <- as.factor(data[[target]])

            data <- jmvcore::naOmit(data)
            
            
            
            
            

            # TODO

            # todo <- glue::glue(
            #     "This Module is still under development
            #     -
            #     -
            #     "
            # )

            # self$results$todo$setContent(todo)

            # if (nrow(self$data) == 0)
            #     stop('Data contains no (complete) rows')


            # if (is.null(self$options$vars) || is.null(self$options$target))
            #     return()


            # prepare data for explore ----
            # https://cran.r-project.org/web/packages/explore/vignettes/explore.html


            # result1 <- iris %>% explore::explain_tree(target = Species)
            #
            # self$results$text1$setContent(result1)


            # image <- self$results$plot

            # image$setState(plotData)



            # from https://forum.jamovi.org/viewtopic.php?f=2&t=1287
            # library(caret)
            # library(partykit)
            # detach("package:partykit", unload=TRUE)
            # library(party)

            # Conditional Trees

            # set.seed(3456)
            # model <- train(
            #     yvar ~ .,
            #     data = df,
            #     method = 'ctree2',
            #     trControl = trainControl("cv", number = 10, classProbs = FALSE),
            #     tuneGrid = expand.grid(maxdepth = 3, mincriterion = 0.95)
            # )
            # plot(model$finalModel)
            #
            # t(sapply(unique(where(model$finalModel)), function(x) {
            #     n <- nodes(model$finalModel, x)[[1]]
            #     yvar <- df[as.logical(n$weights), "yvar"]
            #     cbind.data.frame("Node" = as.integer(x),
            #                      psych::describe(yvar, quant=c(.25,.50,.75), skew = FALSE))
            # }))
            
            
            
            
            


            # data <- private$.cleanData()

            # vars <- self$options$vars
            # facs <- self$options$facs
            # target <- self$options$target

            # tree1 <- data %>%
            #     explore::explain_tree(target = .data[[target]])




            # if (is.null(self$options$vars) || is.null(self$options$target))
            #     return()


            # varsName <- self$options$vars
            #
            # facsName <- self$options$facs
            #
            # targetName <- self$options$target
            #
            # data <- jmvcore::select(self$data, c(varsName, facsName, targetName))
            #
            # data[[varsName]] <- jmvcore::toNumeric(data[[varsName]])
            #
            # for (fac in facsName)
            #     data[[facsName]] <- as.factor(data[[facsName]])
            #
            # data <- jmvcore::naOmit(data)




            # tree1 <- data %>%
            #     explore::explain_tree(target = .data[[targetName]])


            # plot <- iris %>% explore::explain_tree(target = Species)
            # if (length(self$options$dep) + length(self$options$group) < 2)
            #     return()

            # tree1 <- iris %>% explore::explain_tree(target = Species)
            # iris$is_versicolor <- ifelse(iris$Species == "versicolor", 1, 0)
            # tree2 <- iris %>%
            # dplyr::select(-Species) %>%
            # explore::explain_tree(target = is_versicolor)
            # tree3 <- iris %>%
            # explore::explain_tree(target = Sepal.Length)









```{r explore}
library(magrittr)
# devtools::install(upgrade = FALSE, quick = TRUE)
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

mydata <- deneme

varsName <- "Age"

# facsName <- c("LVI", "PNI")

targetName <- "Outcome"

mydata[[targetName]] <- as.factor(mydata[[targetName]])

mydata <- jmvcore::select(mydata, c(varsName, 
                                    # facsName, 
                                    targetName))

mydata <- jmvcore::naOmit(mydata)



explore::explain_tree(data = mydata,
                      target = targetName
                      )

mydata %>%
explore::explain_tree(target = .data[[targetName]])
```



```{r explore 2}
iris %>% explore::explain_tree(target = Species)




BreastCancer %>%
                dplyr::select(all_of(mytarget), all_of(myvars)) %>%
                explore::explain_tree(target = .data[[mytarget]])




ClinicoPath::tree(
    data = data,
    vars = Age,
    facs = vars(LVI, PNI),
    target = Mortality)





```








<!-- mytarget <- "Class" -->
<!-- myvars <- c("Cl.thickness", -->
<!--             "Cell.size", -->
<!--             "Cell.shape", -->
<!--             "Marg.adhesion", -->
<!--             "Epith.c.size", -->
<!--             "Bare.nuclei", -->
<!--             "Bl.cromatin", -->
<!--             "Normal.nucleoli", -->
<!--             "Mitoses") -->

<!-- # mytarget <- jmvcore::composeTerms(mytarget) -->
<!-- # mytarget <- jmvcore::constructFormula(terms = mytarget) -->



```{r easyalluvial}
# install.packages("easyalluvial")
library(magrittr)
# devtools::install(upgrade = FALSE, quick = TRUE)
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

mydata <- deneme

var1 <- "TStage"

var2 <- "Grade"

mydata <- jmvcore::select(df = mydata, columnNames = c(var1, var2))

mydata <- jmvcore::naOmit(mydata)

easyalluvial::alluvial_wide( data = mydata
                , max_variables = 5
                , fill_by = 'first_variable' )




```

